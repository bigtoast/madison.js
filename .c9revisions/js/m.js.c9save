{"ts":1370034195024,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1370036501262,"patch":[[{"diffs":[[1,"\nfunction Algebros(){\n        \n}\n\nfunction Matrix(obj){\n    this.cols = obj.cols;\n    this.rows = obj.rows;\n}\n\nMatrix.identity = function(rows,cols,type) {\n    if ( type === undefined) {\n        type = Int32Array;\n    }\n    var m = new type(rows * cols);\n\n}\n\nAlgebros.prototype = {\n    \n}"]],"start1":0,"start2":0,"length1":0,"length2":288}]],"length":288,"saved":false}
{"ts":1370036698021,"patch":[[{"diffs":[[0,"j.rows;\n"],[1,"    \n    if ( obj.type === undefined ) {\n        this.type = Int32Array;\n    } else {\n        this.type = obj.type;\n    }\n    \n    this.underlying = new this.type(this.cols * this.rows);\n"],[0,"}\n\nMatri"]],"start1":100,"start2":100,"length1":16,"length2":203}]],"length":475,"saved":false}
{"ts":1370040238895,"patch":[[{"diffs":[[0,"    if ("],[1," obj.underlying !== undefined ) {\n        this.underlying = obj.underlying;\n        this.type = typeof(obj.underlying);\n    } else {\n        if ("],[0," obj.typ"]],"start1":113,"start2":113,"length1":16,"length2":161},{"diffs":[[0,"= undefined ) {\n"],[1,"    "],[0,"        this.typ"]],"start1":278,"start2":278,"length1":32,"length2":36},{"diffs":[[0,"2Array;\n    "],[1,"  "],[1,"  "],[0,"} else {\n   "]],"start1":322,"start2":322,"length1":24,"length2":28},{"diffs":[[0,"       } else {\n"],[1,"    "],[0,"        this.typ"]],"start1":331,"start2":331,"length1":32,"length2":36},{"diffs":[[0,"j.type;\n"],[1,"    "],[0,"    }\n  "]],"start1":373,"start2":373,"length1":16,"length2":20},{"diffs":[[0,"      }\n    "],[-1,"\n"],[0,"    this.und"]],"start1":383,"start2":383,"length1":25,"length2":24},{"diffs":[[0,".rows);\n"],[1,"    }\n  \n"],[0,"}\n\nMatri"]],"start1":447,"start2":447,"length1":16,"length2":25},{"diffs":[[0,"s);\n"],[-1,"\n}\n\nAlgebros.prototype ="],[1,"    var i = 0;\n    for ( var r = 0; r < rows; r++ ){\n        for ( var c = 0; c < cols; c++ ){\n          i = r + c;\n          m[r + c] = 0;  \n        }\n        m[i - r] = 1;\n    }\n    return new Matrix({rows : rows, cols : cols, underlying : m});\n}\n\nMatrix.prototype = {\n    \n    toString : function(){\n        var str = \"|\";\n        for ( var r = 0; r < this.rows; r++ ) {\n            for ( var c = 0; c < this.cols; c ++ ) {\n                    \n            }\n            str = str + \"|\\n\";\n        }\n        str = str + \"|\";\n    }\n}\n\nvar Utils = {}\n\nUtils.pad = function(in, length)"],[0," {\n "]],"start1":607,"start2":607,"length1":32,"length2":593},{"diffs":[[0,"th) {\n    \n}"],[-1,""],[0,""],[1,"\n\n"]],"start1":1193,"start2":1193,"length1":12,"length2":14}]],"length":1207,"saved":false}
{"contributors":[],"silentsave":false,"ts":1371245144971,"patch":[[{"diffs":[[0,"\n"],[1,"var DEFAULT_MATRIX_TYPE = Int32Array;\n\nfunction checkType(type, def){\n  if ( type === undefined && def === undefined ) {\n    type = DEFAULT_MATRIX_TYPE;\n  } else if ( type === undefined ) {\n    type = def;\n  }\n  \n  return type;\n}\n\n"],[0,"function Algebro"]],"start1":0,"start2":0,"length1":17,"length2":248},{"diffs":[[0,"s(){"],[-1,"\n        \n"],[0,"}\n\nf"]],"start1":248,"start2":248,"length1":18,"length2":8},{"diffs":[[0,"j.rows;\n"],[-1,"    "],[0,"\n    if "]],"start1":321,"start2":321,"length1":20,"length2":16},{"diffs":[[0,"f ( obj."],[-1,"underlying"],[1,"data"],[0," !== und"]],"start1":335,"start2":335,"length1":26,"length2":20},{"diffs":[[0,"his."],[-1,"underlying = obj.underlying;\n        this.type = typeof(obj.underlying)"],[1,"data = obj.data;\n        this.type = obj.data.constructor"],[0,";\n  "]],"start1":375,"start2":375,"length1":79,"length2":65},{"diffs":[[0,"this.type = "],[-1,"Int32Array"],[1,"DEFAULT_MATRIX_TYPE"],[0,";\n        } "]],"start1":503,"start2":503,"length1":34,"length2":43},{"diffs":[[0,"   this."],[-1,"underlying"],[1,"data"],[0," = new t"]],"start1":602,"start2":602,"length1":26,"length2":20},{"diffs":[[0,"    }\n  \n}\n\n"],[1,"/** create new identity matrix */\n"],[0,"Matrix.ident"]],"start1":655,"start2":655,"length1":24,"length2":58},{"diffs":[[0,"    "],[-1,"if ( type === undefined) {\n        type = In"],[1,"type = checkType(type);\n    \n    var m = new type(rows * cols);\n    var i = 0;\n    for ( var r = 0; r < rows; r++ ){\n        for ( var c = 0; c < cols; c++ ){\n          console.log(\"i: \" + i);\n          m[i++] = 0;  \n        }\n        console.log(cols * r + r);\n        m[cols * r + r] = 1;\n        console.log(m);\n    }\n    return new Matrix({rows : rows, cols : cols, data : m});\n};\n\n/** create a new zero matrix */\nMatrix.zero = function(rows,cols,type) {\n  type = checkType(type);\n  var data = new type(rows * cols);\n  for ( var i = 0; i < data.length; i++){\n    data[i] = 0;\n  }\n  return new Matrix({rows : rows, cols : cols, data : data });\n};\n\n/** return matrix of set size with uninitialized values. */\nMatrix.empty = function( rows, cols, type) {\n  type = checkType(type);\n  var data = new type(rows * cols);\n  return new Matrix({rows : rows, cols : cols, data : data });\n};\n\n/** 2d rotational matrix */\nMatrix.rot2d = function(radians, type) {\n  type = checkType(type, Floa"],[0,"t32Array"],[1,")"],[0,";\n  "],[-1,"  }\n    var m = new type(rows * cols);\n    var i = 0;"],[1,"var data = new type(4);\n  data[0] = Math.cos(radians);\n  data[1] = 0 - Math.sin(radians);\n  data[2] = Math.sin(radians);\n  data[3] = Math.cos(radians);\n  return new Matrix({rows: 2, cols: 2, data :data});\n};\n\n/** 3d rotational matrix around x axis */\nMatrix.rot3dX = function(radians, type){\n  type = checkType(type, Float32Array);\n  var data = new type(9);\n  data[0] = 1;\n  data[1] = 0;\n  data[2] = 0;\n  data[3] = 0;\n  data[4] = Math.cos(radians);\n  data[5] = 0 - Math.sin(radians);\n  data[6] = 0;\n  data[7] = Math.sin(radians);\n  data[8] = Math.cos(radians);\n  return new Matrix({rows: 3, cols: 3, data :data});\n};\n\n/** 3d rotational matrix around y axis */\nMatrix.rot3dY = function(radians, type){\n  type = checkType(type, Float32Array);\n  var data = new type(9);\n  data[0] = Math.cos(radians);\n  data[1] = 0;\n  data[2] = Math.sin(radians);\n  data[3] = 0;\n  data[4] = 1;\n  data[5] = 0;\n  data[6] = 0 - Math.sin(radians);\n  data[7] = 0;\n  data[8] = Math.cos(radians);\n  return new Matrix({rows: 3, cols: 3, data :data});\n};\n\n/** 3d rotational matrix around z axis */\nMatrix.rot3dZ = function(radians, type){\n  type = checkType(type, Float32Array);\n  var data = new type(9);\n  data[0] = Math.cos(radians);\n  data[1] = 0 - Math.sin(radians);\n  data[2] = 0;\n  data[3] = Math.sin(radians);\n  data[4] = Math.cos(radians);\n  data[5] = 0;\n  data[6] = 0;\n  data[7] = 0;\n  data[8] = 1;\n  return new Matrix({rows: 3, cols: 3, data :data});\n};\n\n/** transpose a matrix.. rows become columns.. columns become rows */\nMatrix.transpose = function(m1, out) {\n  if ( out === undefined ) {\n    out = Matrix.empty(m1.cols, m1.rows, m1.type);\n  }\n  \n  for ( var r = 0; r < m1.rows; r++ ) {\n    for ( var c = 0; c < m1.cols; c++ ) {\n      out.set(c,r, m1.get(r,c));\n    }\n  }\n  return out;\n}\n\n/** multiply two matricies or multiply a matrix and a scalar. The second param\n *  should be the scalar value \n */\nMatrix.mult = function(f, s, out){\n  if ( typeof(s) === \"number\" ) {\n    // scalar multiplication\n    if ( out === undefined ) {\n      out = Matrix.zero(f.rows,f.cols,f.type);\n    }\n    for ( var i = 0; i < f.data.length; i++ ) {\n      out.data[i] = f.data[i] * s;\n    }\n    return out;\n  } else {\n    // matrix multiplication\n    // ( m x n ) * ( n x p ) = ( m x p ) \n    // ( row x col ) .. col of first must match rows of second\n    // outsize will be f.rows x s.cols\n    if ( f.cols !== s.rows ) {\n      throw \"Cols of first \" + f.cols + \" doesn't match row cound \" + s.rows + \" of second.\";\n    } \n    \n    if ( out === undefined ) {\n      out = Matrix.zero(f.rows, s.cols, f.type);\n    }\n"],[0,"\n   "]],"start1":746,"start2":746,"length1":117,"length2":3587},{"diffs":[[0,"r ( var "],[1,"f"],[0,"r = 0; "],[1,"f"],[0,"r < "],[1,"f."],[0,"rows; "],[1,"f"],[0,"r++ )"],[1," {\n      for ( var fc = 0; fc < s.cols; fc++ ) "],[0,"{\n      "]],"start1":4336,"start2":4336,"length1":38,"length2":90},{"diffs":[[0," ( var c"],[1,"om"],[0," = 0;"],[1," "],[0," c"],[1,"om"],[0," < "],[1,"f."],[0,"cols; c"],[-1,"++ )"],[1,"om++) "],[0,"{\n      "]],"start1":4431,"start2":4431,"length1":37,"length2":46},{"diffs":[[0,"    "],[-1,"i = r + c"],[1,"out.set(fr, fc, out.get(fr,fc) + (f.get(fr,com) * s.get(com,fc) ));\n        }\n      }\n    }\n    \n    return out;\n  }\n};\n\nMatrix.add = function(m1, m2, out) {\n  if ( m1.data.length !== m2.data.length ) {\n    throw \"M1 size \" + m1.data.length + \" does not equal M2 \" + m2.data.length;\n  }\n  \n  if ( out === undefined ) {\n    out = Matrix.empty(m1.rows, m1.cols)"],[0,";\n  "],[1,"}\n"],[0,"  "],[1,"\n"],[0,"  "],[-1,"    m[r + c] = 0;  \n      "],[1,"for ( var i = 0; i < m1.data.length; i++ ) {\n    out[i] = m1.data[i] + m1.data[i];  \n  }\n  \n  return out;\n};\n\nMatrix.minus = function(m1, m2, out) {\n  if ( m1.data.length !== m2.data.length ) {\n    throw \"M1 size \" + m1.data.length + \" does not equal M2 \" + m2.data.length;\n  }\n  \n  if ( out === undefined ) {\n    out = Matrix.empty(m1.rows, m1.cols, m1.type);\n  }\n  \n  for ( var i = 0; i < m1.data.length; i++ ) {\n    out[i] = m1.data[i] - m1.data[i];  \n"],[0,"  }\n  "],[1,"\n"],[0,"  "],[-1,"    m[i - r] = 1;\n    }\n    return new Matrix({rows : rows, cols : cols, underlying : m});\n}\n\nMatrix.prototype = {"],[1,"return out;\n};\n\n/** calculate the determinant of matrix m1. */\nMatrix.det = function(m1) {\n  if ( ! m1.isSquare() ) {\n    throw \"Cannot calculate determinant of non-square matrix\";\n  }\n  \n  if ( m1.rows === 2 ) {\n    return ( m1.data[0] * m1.data[3] ) - ( m1.data[1] * m1.data[2] );  \n  } else {\n    var agg = 0;\n    var temp = Matrix.empty(m1.rows - 1, m1.cols - 1, m1.type);\n    for ( var c = 0; c < m1.cols; c++ ) {\n      if ( c % 2 === 0 ) {\n        agg = agg + ( m1.get(0,c) * Matrix.det( Matrix.sub(m1,0,c,temp) ) );  \n      } else {\n        agg = agg - ( m1.get(0,c) * Matrix.det( Matrix.sub(m1,0,c,temp) ) );  \n      }\n    }\n    return agg;\n  }\n};\n\n/** return the submatrix of m1 by removing row and column. This will return a matrix\n * of size ( m1.rows - 1 X m1.cols -1 )\n */\nMatrix.sub = function(m1, row, col, out) {\n  if ( out === undefined ) {\n    out = Matrix.empty(m1.rows - 1, m1.cols - 1, m1.type);\n  }\n  \n  var i = 0;\n  var o = 0;\n  for ( var r = 0; r < m1.rows; r++ ) {\n    for ( var c = 0; c < m1.cols; c++ ) {\n      if ( ! ( r === row || c === col ) ) {\n        out.data[o++] = m1.data[i];\n      }\n      i++;\n    }\n  }\n  return out;\n};\n\nMatrix.invert = function(m1, out) {\n  if ( ! m1.isSquare() ) {\n    throw \"You cannot invert a nonsquare matrix\";\n  }\n  \n  if ( out === undefined ) {\n    out = Matrix.empty(m1.rows, m1.cols, m1.type);\n  }\n  \n  var d = 1 / Matrix.det(m1);\n  \n  if ( m1.rows === 2 ) {\n    \n  } else {\n    var d = 1 / Matrix.det(m1);\n  }\n\n};\n\nMatrix.echelon = function( m, out ) {\n    var lead = 0;\n    for ( var r = 0; r = m.rows; r++ ) {\n        if ( m.cols <= lead ) {\n            return \"FUCK\"\n        } else {\n            var i = r;\n            while ( m.get(r,lead) === 0 ) {\n                if ( m.rows === i ) {\n                    i = r;\n                    lead = lead + 1;\n                    if ( m.cols === lead ) {\n                        return \"fuuuck\"\n                    }\n                }\n            }\n        }\n    }\n};\n\nMatrix.prototype = {\n    \n    mult : function(other, out) {\n      return Matrix.mult(this, other, out);\n    },\n    \n    add : function(other, out) {\n      return Matrix.add(this,other,out);\n    },\n    \n    minus : function(other, out){\n      return Matrix.minus(this,other,out);\n    },\n    \n    transpose : function(out) {\n      return Matrix.transpose(this,out);\n    },\n    \n    isSquare : function() {\n      return this.cols === this.rows;\n    },\n    \n    sub : function(row,col,out){\n      return Matrix.sub(this,row,col,out);\n    },"],[0,"\n   "]],"start1":4477,"start2":4477,"length1":173,"length2":3359},{"diffs":[[0," str = \""],[-1,"|"],[0,"\""],[1,";\n        var i = 0"],[0,";\n      "]],"start1":7876,"start2":7876,"length1":18,"length2":36},{"diffs":[[0,"s.rows; r++ ) {\n"],[1,"            str = str + \"|\";\n"],[0,"            for "]],"start1":7938,"start2":7938,"length1":32,"length2":61},{"diffs":[[0,"        "],[-1,"      "],[1,"str = str + \" \" + this.data[i++] + \" \";"],[0,"\n       "]],"start1":8042,"start2":8042,"length1":22,"length2":55},{"diffs":[[0,"    "],[-1,"str = str + \"|\";\n    }\n}"],[1,"return str;\n    },\n    \n    /** return the value at a given row and col idx. if just a single value\n      * is given the value of idx of the underlying array is given          */\n    get : function(rowIdx,colIdx) {\n      if ( colIdx === undefined) {\n        return this.data[rowIdx];\n      } else {\n        return this.data[(this.cols * rowIdx ) + colIdx];\n      }\n    },\n    \n    set : function(rowIdx, colIdx, value) {\n      if ( value === undefined ) {\n        console.log(\"undif\");\n        this.data[rowIdx] = colIdx;\n      } else {\n        console.log((this.cols * rowIdx) + colIdx + \" - \" + value);\n        this.data[(this.cols * rowIdx) + colIdx] = value;\n      }\n      return this;\n    }\n};"],[0,"\n\nva"]],"start1":8149,"start2":8149,"length1":32,"length2":706},{"diffs":[[0,"ils = {}"],[1,";"],[0,"\n\nUtils."]],"start1":8859,"start2":8859,"length1":16,"length2":17},{"diffs":[[0,"ion("],[-1,"in"],[1,"str"],[0,", len"],[-1,"gth"],[0,") {\n"]],"start1":8887,"start2":8887,"length1":18,"length2":16},{"diffs":[[0,"en) {\n    \n}"],[-1,""],[0,""],[1,";"],[0,"\n\n"]],"start1":8897,"start2":8897,"length1":14,"length2":15}]],"length":8912,"saved":false}
